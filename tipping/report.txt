1.
In this query, a simple select from the Customer table was used in order to test different\n access paths for simple queries. In this case, our predicate checked a range of cust# values\n from the table. In the case of oneB.sql, the entire range of possible cust# values\n was used as the value of the predicate. In the case of oneA.sql, the range was \nrestricted as to only have one value (cust#=4) satisfying the predicate. When comparing \nthe plan files for both of these queries, we can see that the estimated cardinalities are\n vastly different because of the values of these predicates. This causes the evaluator\n to have an index scan as part of the access path for oneA.sql, since we are only \nlooking for a restricted number of values, while the access path for oneB.sql does not \ncontain this index scan. Thus the access paths for the two variants are different.\n

2.
Thinking about this problem logically, we noticed that the aggregation operations would \nrequire a sort when a group by clause was used since db2 would need to sort the tuples on\n the grouping attribute, which in the case of our query was price. It would then need to\n watch for group boundaries in order to compute the aggregate value for each group. In\n our query twoB.sql, we compute the most expensive book for each genre (by using all genres\n as the value of the predicate), which requires an explicit sort of the tuples on genre. In\n our query twoA.sql, the value of our predicate is a single genre. This means that no \nexplicit sort is required since there is only one value of the grouping attribute. This\n means a simple scan can be performed, checking if the genre is Education, and seeing if the \nprice is higher than the highest we have seen so far. This is similar to a simple scan to\n find the max of all books.\n

3.
In this query, the initial idea was to use a field that had an index on it, since this would \nbe required to get the index nested loop join to work for one of the variants. In the case \nof the query threeA.sql, an inner join on all three tables is performed by using the book#\n fields in the Book and Purchase tables and the cust# fields in the Customer and\n Purchase tables. The resulting query plan shows that a hash join is used in order to join\n the tables. In the query threeB.sql, instead of performing an inner join on Purchase and \nCustomer, the value of the predicate is changed to find a single customer (the customer \nwith cust#=4). This causes the index to be more useful since we know the location of the\n row with cust#=4. This causes the index nested loop join to be used instead of hash join.\n

4.

5.