Alternative 4.

In this query, we knew that the join order was going to be dependant on the size of the tables being joined in the query since the optimizer will choose the one that will result in a better I/O cost in the end. In both fourA.sql and fourB.sql we perform a simple inner join on the three tables Book, Customer and Purchase. In fourA, we want tuples with the customer number between 4 and 10000, which is practically all of the customers. This caused a join of Customer and Purchase, which was then joined with Book. In fourB, we want only tuples with customer number between 4 and 4 (which is the same as saying equal to 4 but used in order to keep the predicate the same). This caused a join of Purchase and Book, which was then joined with Customer. This was the case because the IO cost would have been higher if the plan joined Customer and Purchase together first and then Book since we were only looking at a single cust# in the case of fourB.sql.
